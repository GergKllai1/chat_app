# Basic chat app using Rails ActionCable functionality

We will be building a basic chat app to learn about the [ActionCable functionality](https://guides.rubyonrails.org/action_cable_overview.html) which uses [websockets](https://en.wikipedia.org/wiki/WebSocket) protocol.

Our App will have following features:

- User Authentication
- Push notifications in chat windows
- List of chats and list of available users

`Disclaimer: This guide assumes a basic familiarity with rails development, like assoications and user authentication.`

## Basic setup

### Scaffold a rails application

First scaffold basic rails app

`rails new chat_app --database=postgresql --skip-test --skip-bundle`

Set up [Cucumber](https://github.com/cucumber/cucumber-rails) for testing.

### Set up Devise

Set up [devise](https://github.com/plataformatec/devise) which will be used for user authentication.

### Generate models

Now comes the fun part!
We will need two models other then the **User** model generated by devise: **Chat** and **Message** .

**Chat** model will be empty and **Message** model will have a 'text' column with string datatype.

Use the following commands:

`rails g model Chat` and `rails g model Message text:string`

to generate each.

### Set up associations

Now is the time to add associations!

1. **Chats** and **Messages** have `has_many` & `belongs_to` associations.
2. **Users** and **Messages** have `has_many` & `belongs-to` associations.
3. **Chats** and **Users** have `has_many_and_belongs_to` association(!).

To do this run the following commands:

```rails
rails g migration CreateJoinTableUserChat user chat
rails g migration AddUserRefToMessages user:references
rails g migration AddChatRefToMessages chat:references
rails db:migrate
```

And add the associations:

```ruby
#app/models/chat.rb
class Chat < ApplicationRecord
  has_and_belongs_to_many :users
  has_many :messages
end
```

```ruby
#app/models/message.rb
class Message < ApplicationRecord
  belongs_to :chat
  belongs_to :user
end
```

```ruby
#app/models/user.rb
class User < ApplicationRecord
  # Include default devise modules. Others available are:
  # :confirmable, :lockable, :timeoutable, :trackable and :omniauthable
  devise :database_authenticatable, :registerable,
         :recoverable, :rememberable, :validatable
  has_and_belongs_to_many :chats
  has_many :messages
end
```

### Set up Chat controller and starter views

Set up chat and messages controllers with basic index and show action. Create `chat_controller.rb` with the following code:

```ruby
#app/controllers/chat_controller.rb
class ChatController < ApplicationController
  def index
    @chats = current_user.chats
  end

  def show
      @messages = Message.where(chat_id: params[:id])
    end
end
```

Set up routes in `routes.rb`. We will use `chat#index` as root path.

```ruby
#config/routes.rb
Rails.application.routes.draw do
  root controller: :chat, action: :index
  devise_for :users
  resources :chat, only: [:index, :show]
end
```

And to finish off add 3 views to start with. First we add a navbar partial and render it in `chat#index` so that we are able to log in and out

```ruby
#app/views/partials/_navbar.html.haml
=link_to 'Home', root_path
-unless user_signed_in?
  =link_to 'Register', new_user_registration_path
  =link_to 'Login', new_user_session_path
- else
  =link_to 'Logout', destroy_user_session_path, { method: :delete }
  %span=current_user.email
```

After that we add the index view for chat:

```ruby
#app/view/chat/index.html.haml
= render partial: 'partials/navbar'

-@chats.each do |chat|
  =link_to "Chat between #{chat.users.first.email} and #{chat.users.second.email}", chat_path(chat.id)
```

To finish up this we need to add the chat show page as well:

```ruby
#app/view/chat/show.html.haml
-@messages.each do |message|
  %p= "#{message.user.email} says: #{message.text}"
```

To see this in action we need to add some data, the easiest way is through the seed file. Let's add the following code to it:

```Ruby
#db/seed.rb
Message.destroy_all
Chat.destroy_all
User.destroy_all

user1 = User.create(email: 'user1@mail.com', password:'password')
user2 = User.create(email: 'user2@mail.com', password:'password')
user3 = User.create(email: 'user3@mail.com', password:'password')

chat_1 = Chat.create()
chat_1.users << user1
chat_1.users << user2

chat_2 = Chat.create()
chat_2.users << user1
chat_2.users << user3
```

Now if you run `rails db:seed` and `rails s` you should be able to login and see 2 chat links for user1.

### Create Message controller

Now we should continue by adding a `message_controller` with only create action. For this implementation we will use `chat#show` to render the message form.

Add the following file:

```ruby
#app/controllers/message_controller
class MessageController < ApplicationController
  def create
    message = current_user.messages.new(message_params)
    chat = Chat.find_by_id(message_params[:chat_id])
    if message.save
      redirect_to chat_path(chat)
    end
  end

  private

  def message_params
    params.require(:message).permit(:text, :chat_id)
  end
end
```

The `message = current_user.messages.new(message_params)` uses the `has_many` association to create a message connected to the current user already, which makes for a drier code.

Add the path to the `routes.rb`:

```ruby
#config/routes.rb
Rails.application.routes.draw do
  root controller: :chat, action: :index
  devise_for :users
  resources :chat, only: [:index, :show]
  resources :message, only: [:create]
end
```

And finally add the form to the `chat#show` view:

```ruby
#app/view/chat/show.html.haml
-@messages.each do |message|
  %p= "#{message.user.email} says: #{message.text}"

= form_with scope: :message, url: message_index_path, local: true do | form |
  %p
    = form.label 'Send Message'
    %br/
    = form.text_field :text
    = form.hidden_field :chat_id, value: @chat.id
  %p
    = form.submit "Send"
```

We need to pass down the `chat_id` using a hidden field so the message can be connected to the chat.

Now we have a chat with 2 users, and a form where we can create messages. We render those messages in the `chat#show`, and when you type you see them appearing. This is because rails redirects us to that page and fetches the information again. That is not the behaviour we are looking for, we need to show them appear dynamically. This is where ActionCable comes into play.

## Set up ActionCable

## Styling
